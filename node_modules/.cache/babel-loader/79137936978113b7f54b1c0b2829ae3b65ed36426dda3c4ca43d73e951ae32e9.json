{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v2.0.1\n* undefined\n * (c) 2016-2023 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign, getRelativePosition } from 'chart.js/helpers';\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart\n    }).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({\n      chart\n    });\n  }\n  if (typeof mode === 'string') {\n    return {\n      x: mode.indexOf('x') !== -1,\n      y: mode.indexOf('y') !== -1\n    };\n  }\n  return {\n    x: false,\n    y: false\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/**\n * Checks which axis is under the mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint(_ref, chart) {\n  let {\n    x,\n    y\n  } = _ref;\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/**\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\n * determine which axes are eligible for scaling.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param options - Zoom or pan options\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {\n    mode = 'xy',\n    scaleMode,\n    overScaleMode\n  } = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  const minPercent = Math.max(0, Math.min(1, (scale.getValueForPixel(centerPoint) - scale.min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction updateRange(scale, _ref2, limits) {\n  let {\n    min,\n    max\n  } = _ref2;\n  let zoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const state = getState(scale.chart);\n  const {\n    id,\n    axis,\n    options: scaleOpts\n  } = scale;\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {\n    minRange = 0\n  } = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  const range = zoom ? Math.max(max - min, minRange) : scale.max - scale.min;\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n  state.updatedScaleLimits[scale.id] = {\n    min,\n    max\n  };\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, getRange(scale, from, to), limits, true);\n}\nconst integerChange = v => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {\n    min,\n    max\n  } = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {\n    min,\n    max\n  }, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  // 500 ms\n  minute: 30 * 1000,\n  // 30 s\n  hour: 30 * 60 * 1000,\n  // 30 m\n  day: 12 * 60 * 60 * 1000,\n  // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000,\n  // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits) {\n  let canZoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const {\n    min: prevStart,\n    max: prevEnd,\n    options\n  } = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {\n    min: minLimit = -Infinity,\n    max: maxLimit = Infinity\n  } = canZoom && limits && limits[scale.axis] || {};\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, canZoom);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {\n    id,\n    options: {\n      min,\n      max\n    }\n  } = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {\n    scales\n  } = chart;\n  const {\n    originalScaleLimits,\n    updatedScaleLimits\n  } = state;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, amount, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, amount, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount) {\n  let transition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n  const {\n    x = 1,\n    y = 1,\n    focalPoint = getCenter(chart)\n  } = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount;\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\nfunction zoomRect(chart, p0, p1) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  const {\n    mode = 'xy'\n  } = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart\n  }]);\n}\nfunction zoomScale(chart, scaleId, range) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\nfunction resetZoom(chart) {\n  let transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart\n  }]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {\n    min,\n    max\n  } = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function (scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {\n    panDelta\n  } = state;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  const {\n    x = 0,\n    y = 0\n  } = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta;\n  const state = getState(chart);\n  const {\n    options: {\n      pan: panOptions,\n      limits\n    }\n  } = state;\n  const {\n    onPan\n  } = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart\n  }]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min,\n      max\n    } = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    };\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min: originalMin,\n      max: originalMax\n    } = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction removeHandler(chart, type) {\n  const {\n    handlers\n  } = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {\n    handlers,\n    options\n  } = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    // already attached\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = event => handler(chart, event, options);\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {\n    onZoomStart,\n    onZoomRejected\n  } = zoomOptions;\n  if (onZoomStart) {\n    const point = getRelativePosition(event, chart);\n    if (callback(onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {\n    pan: panOptions,\n    zoom: zoomOptions = {}\n  } = state.options;\n  if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction computeDragRect(chart, mode, beginPointEvent, endPointEvent) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {\n    top,\n    left,\n    right,\n    bottom,\n    width: chartWidth,\n    height: chartHeight\n  } = chart.chartArea;\n  const beginPoint = getRelativePosition(beginPointEvent, chart);\n  const endPoint = getRelativePosition(endPointEvent, chart);\n  if (xEnabled) {\n    left = Math.min(beginPoint.x, endPoint.x);\n    right = Math.max(beginPoint.x, endPoint.x);\n  }\n  if (yEnabled) {\n    top = Math.min(beginPoint.y, endPoint.y);\n    bottom = Math.max(beginPoint.y, endPoint.y);\n  }\n  const width = right - left;\n  const height = bottom - top;\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {\n    mode,\n    onZoomComplete,\n    drag: {\n      threshold = 0\n    }\n  } = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom');\n  setTimeout(() => state.dragging = false, 500);\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {\n    handlers: {\n      onZoomComplete\n    },\n    options: {\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{\n      chart\n    }]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {\n    wheel: wheelOptions,\n    drag: dragOptions,\n    onZoomComplete\n  } = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    const {\n      pan: panOptions,\n      zoom: zoomOptions = {}\n    } = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {\n      center,\n      pointers\n    } = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{\n      chart\n    }]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\nfunction startPan(chart, state, event) {\n  const {\n    enabled,\n    onPanStart,\n    onPanRejected\n  } = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{\n    chart,\n    event,\n    point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart,\n      event\n    }]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => state.panning = false, 500);\n    callback(state.options.pan.onPanComplete, [{\n      chart\n    }]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = options;\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', e => handlePinch(chart, state, e));\n    mc.on('pinchend', e => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', e => startPan(chart, state, e));\n    mc.on('panmove', e => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nvar version = \"2.0.1\";\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {\n    dragStart,\n    dragEnd\n  } = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {\n    left,\n    top,\n    width,\n    height\n  } = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function (chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode') || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = transition => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n  beforeUpdate: function (chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function (chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };","map":{"version":3,"names":["Hammer","each","valueOrDefault","callback","sign","getRelativePosition","getModifierKey","opts","enabled","modifierKey","keyPressed","key","event","keyNotPressed","directionEnabled","mode","dir","chart","undefined","indexOf","directionsEnabled","x","y","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","_ref","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","options","point","scaleMode","overScaleMode","scaleEnabled","overScaleEnabled","axis","enabledScales","scaleItem","push","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","panDelta","set","removeState","delete","zoomDelta","zoom","center","range","max","min","newRange","centerPoint","isHorizontal","minPercent","Math","getValueForPixel","maxPercent","getLimit","scaleLimits","prop","fallback","limit","original","id","getRange","pixel0","pixel1","v0","v1","updateRange","_ref2","limits","arguments","scaleOpts","minRange","minLimit","Infinity","maxLimit","offset","parse","zoomNumericalScale","delta","zoomRectNumericalScale","from","to","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","canZoom","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","default","zoomRectFunctions","panFunctions","logarithmic","timeseries","shouldUpdateScaleLimits","previous","removeMissingScales","opt","storeOriginalScaleLimits","doZoom","amount","type","doZoomRect","getCenter","ca","chartArea","transition","focalPoint","zoomOptions","xEnabled","yEnabled","update","onZoom","zoomRect","p0","p1","zoomScale","scaleId","resetZoom","scaleOptions","onZoomComplete","getOriginalRange","getZoomLevel","origRange","level","panScale","storedDelta","pan","panOptions","onPan","getInitialScaleBounds","scaleBounds","isZoomedOrPanned","originalMin","originalMax","removeHandler","handler","target","removeEventListener","addHandler","oldHandler","addEventListener","mouseMove","dragStart","dragging","dragEnd","keyDown","zoomStart","onZoomStart","onZoomRejected","mouseDown","button","drag","canvas","window","document","computeDragRect","beginPointEvent","endPointEvent","chartWidth","chartHeight","beginPoint","endPoint","zoomX","zoomY","mouseUp","threshold","rect","distanceX","distanceY","distance","sqrt","wheelPreconditions","wheel","cancelable","preventDefault","deltaY","getBoundingClientRect","speed","clientX","clientY","addDebouncedHandler","name","addListeners","wheelOptions","dragOptions","ownerDocument","removeListeners","createEnabler","recognizer","srcEvent","panning","pointerType","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","onPanStart","panEndTimeout","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","version","draw","caller","drawTime","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","beforeUpdate","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","stop"],"sources":["/Users/tommymarkopoulos/Desktop/coding/Git_Repos/chess-stats-app/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-zoom v2.0.1\n* undefined\n * (c) 2016-2023 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign, getRelativePosition } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({chart});\n  }\n  if (typeof mode === 'string') {\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\n  }\n\n  return {x: false, y: false};\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/**\n * Checks which axis is under the mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/**\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\n * determine which axes are eligible for scaling.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param options - Zoom or pan options\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  const minPercent = Math.max(0, Math.min(1,\n    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0\n  ));\n\n  const maxPercent = 1 - minPercent;\n\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {id, axis, options: scaleOpts} = scale;\n\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n\n  const range = zoom ? Math.max(max - min, minRange) : scale.max - scale.min;\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n\n  state.updatedScaleLimits[scale.id] = {min, max};\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, getRange(scale, from, to), limits, true);\n}\n\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {min, max}, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500, // 500 ms\n  minute: 30 * 1000, // 30 s\n  hour: 30 * 60 * 1000, // 30 m\n  day: 12 * 60 * 60 * 1000, // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n};\n\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale,\n};\n\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n\n  each(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction doZoomRect(scale, amount, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, amount, from, to, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount, transition = 'none') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {onPan} = panOptions || {};\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(onPan, [{chart}]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    // already attached\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const point = getRelativePosition(event, chart);\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\n\nfunction computeDragRect(chart, mode, beginPointEvent, endPointEvent) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n\n  const beginPoint = getRelativePosition(beginPointEvent, chart);\n  const endPoint = getRelativePosition(endPointEvent, chart);\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.x, endPoint.x);\n    right = Math.max(beginPoint.x, endPoint.x);\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.y, endPoint.y);\n    bottom = Math.max(beginPoint.y, endPoint.y);\n  }\n  const width = right - left;\n  const height = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\n\n  setTimeout(() => (state.dragging = false), 500);\n  callback(onZoomComplete, [{chart}]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) { // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {x: 0, y: 0};\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\n\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"2.0.1\";\n\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {dragStart, dragEnd} = getState(chart);\n\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n  const ctx = chart.ctx;\n\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\n\nvar plugin = {\n  id: 'zoom',\n\n  version,\n\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n\n  stop: function(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n};\n\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}