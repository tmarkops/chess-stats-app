{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v2.0.1\n* undefined\n * (c) 2016-2023 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign, getRelativePosition } from 'chart.js/helpers';\nvar getModifierKey = function getModifierKey(opts) {\n  return opts && opts.enabled && opts.modifierKey;\n};\nvar keyPressed = function keyPressed(key, event) {\n  return key && event[key + 'Key'];\n};\nvar keyNotPressed = function keyNotPressed(key, event) {\n  return key && !event[key + 'Key'];\n};\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart: chart\n    }).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({\n      chart: chart\n    });\n  }\n  if (typeof mode === 'string') {\n    return {\n      x: mode.indexOf('x') !== -1,\n      y: mode.indexOf('y') !== -1\n    };\n  }\n  return {\n    x: false,\n    y: false\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  var timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/**\n * Checks which axis is under the mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint(_ref, chart) {\n  var x = _ref.x,\n    y = _ref.y;\n  var scales = chart.scales;\n  var scaleIds = Object.keys(scales);\n  for (var i = 0; i < scaleIds.length; i++) {\n    var scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/**\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\n * determine which axes are eligible for scaling.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param options - Zoom or pan options\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(options, point, chart) {\n  var _ref2 = options || {},\n    _ref2$mode = _ref2.mode,\n    mode = _ref2$mode === void 0 ? 'xy' : _ref2$mode,\n    scaleMode = _ref2.scaleMode,\n    overScaleMode = _ref2.overScaleMode;\n  var scale = getScaleUnderPoint(point, chart);\n  var enabled = directionsEnabled(mode, chart);\n  var scaleEnabled = directionsEnabled(scaleMode, chart);\n\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\n  if (overScaleMode) {\n    var overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (var _i = 0, _arr = ['x', 'y']; _i < _arr.length; _i++) {\n      var axis = _arr[_i];\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  var enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\nvar chartStates = new WeakMap();\nfunction getState(chart) {\n  var state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction zoomDelta(scale, zoom, center) {\n  var range = scale.max - scale.min;\n  var newRange = range * (zoom - 1);\n  var centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  var minPercent = Math.max(0, Math.min(1, (scale.getValueForPixel(centerPoint) - scale.min) / range || 0));\n  var maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  var limit = scaleLimits[prop];\n  if (limit === 'original') {\n    var original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction getRange(scale, pixel0, pixel1) {\n  var v0 = scale.getValueForPixel(pixel0);\n  var v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction updateRange(scale, _ref3, limits) {\n  var min = _ref3.min,\n    max = _ref3.max;\n  var zoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var state = getState(scale.chart);\n  var id = scale.id,\n    axis = scale.axis,\n    scaleOpts = scale.options;\n  var scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  var _scaleLimits$minRange = scaleLimits.minRange,\n    minRange = _scaleLimits$minRange === void 0 ? 0 : _scaleLimits$minRange;\n  var minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  var maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  var range = zoom ? Math.max(max - min, minRange) : scale.max - scale.min;\n  var offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n  state.updatedScaleLimits[scale.id] = {\n    min: min,\n    max: max\n  };\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  var delta = zoomDelta(scale, zoom, center);\n  var newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, getRange(scale, from, to), limits, true);\n}\nvar integerChange = function integerChange(v) {\n  return v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n};\nfunction existCategoryFromMaxZoom(scale) {\n  var labels = scale.getLabels();\n  var maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  var delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  var newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  var labels = scale.getLabels();\n  var lastLabelIndex = labels.length - 1;\n  var min = scale.min,\n    max = scale.max;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  var range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  var stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  var stepSize = Math.round(Math.abs(delta / stepDelta));\n  var applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {\n    min: min,\n    max: max\n  }, limits) || applied;\n}\nvar OFFSETS = {\n  second: 500,\n  // 500 ms\n  minute: 30 * 1000,\n  // 30 s\n  hour: 30 * 60 * 1000,\n  // 30 m\n  day: 12 * 60 * 60 * 1000,\n  // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000,\n  // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits) {\n  var canZoom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var prevStart = scale.min,\n    prevEnd = scale.max,\n    options = scale.options;\n  var round = options.time && options.time.round;\n  var offset = OFFSETS[round] || 0;\n  var newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  var newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  var _ref4 = canZoom && limits && limits[scale.axis] || {},\n    _ref4$min = _ref4.min,\n    minLimit = _ref4$min === void 0 ? -Infinity : _ref4$min,\n    _ref4$max = _ref4.max,\n    maxLimit = _ref4$max === void 0 ? Infinity : _ref4$max;\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, canZoom);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nvar zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale\n};\nvar zoomRectFunctions = {\n  default: zoomRectNumericalScale\n};\nvar panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  var id = scale.id,\n    _scale$options = scale.options,\n    min = _scale$options.min,\n    max = _scale$options.max;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  var previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, function (opt, key) {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  var scales = chart.scales;\n  var originalScaleLimits = state.originalScaleLimits,\n    updatedScaleLimits = state.updatedScaleLimits;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  var fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, amount, from, to, limits) {\n  var fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, amount, from, to, limits]);\n}\nfunction getCenter(chart) {\n  var ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount) {\n  var transition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';\n  var _ref5 = typeof amount === 'number' ? {\n      x: amount,\n      y: amount\n    } : amount,\n    _ref5$x = _ref5.x,\n    x = _ref5$x === void 0 ? 1 : _ref5$x,\n    _ref5$y = _ref5.y,\n    y = _ref5$y === void 0 ? 1 : _ref5$y,\n    _ref5$focalPoint = _ref5.focalPoint,\n    focalPoint = _ref5$focalPoint === void 0 ? getCenter(chart) : _ref5$focalPoint;\n  var state = getState(chart);\n  var _state$options = state.options,\n    limits = _state$options.limits,\n    zoomOptions = _state$options.zoom;\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = x !== 1;\n  var yEnabled = y !== 1;\n  var enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart: chart\n  }]);\n}\nfunction zoomRect(chart, p0, p1) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  var state = getState(chart);\n  var _state$options2 = state.options,\n    limits = _state$options2.limits,\n    zoomOptions = _state$options2.zoom;\n  var _zoomOptions$mode = zoomOptions.mode,\n    mode = _zoomOptions$mode === void 0 ? 'xy' : _zoomOptions$mode;\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = directionEnabled(mode, 'x', chart);\n  var yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart: chart\n  }]);\n}\nfunction zoomScale(chart, scaleId, range) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  storeOriginalScaleLimits(chart, getState(chart));\n  var scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\nfunction resetZoom(chart) {\n  var transition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n  var state = getState(chart);\n  var originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    var scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart: chart\n  }]);\n}\nfunction getOriginalRange(state, scaleId) {\n  var original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  var min = original.min,\n    max = original.max;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  var state = getState(chart);\n  var min = 1;\n  var max = 1;\n  each(chart.scales, function (scale) {\n    var origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      var level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  var panDelta = state.panDelta;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  var storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  var fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n  var _ref6 = typeof delta === 'number' ? {\n      x: delta,\n      y: delta\n    } : delta,\n    _ref6$x = _ref6.x,\n    x = _ref6$x === void 0 ? 0 : _ref6$x,\n    _ref6$y = _ref6.y,\n    y = _ref6$y === void 0 ? 0 : _ref6$y;\n  var state = getState(chart);\n  var _state$options3 = state.options,\n    panOptions = _state$options3.pan,\n    limits = _state$options3.limits;\n  var _ref7 = panOptions || {},\n    onPan = _ref7.onPan;\n  storeOriginalScaleLimits(chart, state);\n  var xEnabled = x !== 0;\n  var yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart: chart\n  }]);\n}\nfunction getInitialScaleBounds(chart) {\n  var state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  var scaleBounds = {};\n  for (var _i2 = 0, _Object$keys = Object.keys(chart.scales); _i2 < _Object$keys.length; _i2++) {\n    var scaleId = _Object$keys[_i2];\n    var _ref8 = state.originalScaleLimits[scaleId] || {\n        min: {},\n        max: {}\n      },\n      min = _ref8.min,\n      max = _ref8.max;\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  var scaleBounds = getInitialScaleBounds(chart);\n  for (var _i3 = 0, _Object$keys2 = Object.keys(chart.scales); _i3 < _Object$keys2.length; _i3++) {\n    var scaleId = _Object$keys2[_i3];\n    var _scaleBounds$scaleId = scaleBounds[scaleId],\n      originalMin = _scaleBounds$scaleId.min,\n      originalMax = _scaleBounds$scaleId.max;\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction removeHandler(chart, type) {\n  var _getState = getState(chart),\n    handlers = _getState.handlers;\n  var handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  var _getState2 = getState(chart),\n    handlers = _getState2.handlers,\n    options = _getState2.options;\n  var oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    // already attached\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = function (event) {\n    return handler(chart, event, options);\n  };\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\nfunction mouseMove(chart, event) {\n  var state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  var state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  var onZoomStart = zoomOptions.onZoomStart,\n    onZoomRejected = zoomOptions.onZoomRejected;\n  if (onZoomStart) {\n    var point = getRelativePosition(event, chart);\n    if (callback(onZoomStart, [{\n      chart: chart,\n      event: event,\n      point: point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart: chart,\n        event: event\n      }]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  var state = getState(chart);\n  var _state$options4 = state.options,\n    panOptions = _state$options4.pan,\n    _state$options4$zoom = _state$options4.zoom,\n    zoomOptions = _state$options4$zoom === void 0 ? {} : _state$options4$zoom;\n  if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart: chart,\n      event: event\n    }]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction computeDragRect(chart, mode, beginPointEvent, endPointEvent) {\n  var xEnabled = directionEnabled(mode, 'x', chart);\n  var yEnabled = directionEnabled(mode, 'y', chart);\n  var _chart$chartArea = chart.chartArea,\n    top = _chart$chartArea.top,\n    left = _chart$chartArea.left,\n    right = _chart$chartArea.right,\n    bottom = _chart$chartArea.bottom,\n    chartWidth = _chart$chartArea.width,\n    chartHeight = _chart$chartArea.height;\n  var beginPoint = getRelativePosition(beginPointEvent, chart);\n  var endPoint = getRelativePosition(endPointEvent, chart);\n  if (xEnabled) {\n    left = Math.min(beginPoint.x, endPoint.x);\n    right = Math.max(beginPoint.x, endPoint.x);\n  }\n  if (yEnabled) {\n    top = Math.min(beginPoint.y, endPoint.y);\n    bottom = Math.max(beginPoint.y, endPoint.y);\n  }\n  var width = right - left;\n  var height = bottom - top;\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    width: width,\n    height: height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  var state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  var _state$options$zoom = state.options.zoom,\n    mode = _state$options$zoom.mode,\n    onZoomComplete = _state$options$zoom.onZoomComplete,\n    _state$options$zoom$d = _state$options$zoom.drag.threshold,\n    threshold = _state$options$zoom$d === void 0 ? 0 : _state$options$zoom$d;\n  var rect = computeDragRect(chart, mode, state.dragStart, event);\n  var distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  var distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  var distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom');\n  setTimeout(function () {\n    return state.dragging = false;\n  }, 500);\n  callback(onZoomComplete, [{\n    chart: chart\n  }]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart: chart,\n      event: event\n    }]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  var _getState3 = getState(chart),\n    onZoomComplete = _getState3.handlers.onZoomComplete,\n    zoomOptions = _getState3.options.zoom;\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  var rect = event.target.getBoundingClientRect();\n  var speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  var amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount);\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(function () {\n      return callback(handler, [{\n        chart: chart\n      }]);\n    }, delay);\n  }\n}\nfunction addListeners(chart, options) {\n  var canvas = chart.canvas;\n  var _options$zoom = options.zoom,\n    wheelOptions = _options$zoom.wheel,\n    dragOptions = _options$zoom.drag,\n    onZoomComplete = _options$zoom.onZoomComplete;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    var _state$options5 = state.options,\n      panOptions = _state$options5.pan,\n      _state$options5$zoom = _state$options5.zoom,\n      zoomOptions = _state$options5$zoom === void 0 ? {} : _state$options5$zoom;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    var srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart: chart,\n        event: event\n      }]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  var pinchX = Math.abs(p0.clientX - p1.clientX);\n  var pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  var p = pinchX / pinchY;\n  var x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    var center = e.center,\n      pointers = e.pointers;\n    // Hammer reports the total scaling. We need the incremental amount\n    var zoomPercent = 1 / state.scale * e.scale;\n    var rect = e.target.getBoundingClientRect();\n    var pinch = pinchAxes(pointers[0], pointers[1]);\n    var mode = state.options.zoom.mode;\n    var amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{\n      chart: chart\n    }]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  var delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\nfunction startPan(chart, state, event) {\n  var _state$options$pan = state.options.pan,\n    enabled = _state$options$pan.enabled,\n    onPanStart = _state$options$pan.onPanStart,\n    onPanRejected = _state$options$pan.onPanRejected;\n  if (!enabled) {\n    return;\n  }\n  var rect = event.target.getBoundingClientRect();\n  var point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{\n    chart: chart,\n    event: event,\n    point: point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart: chart,\n      event: event\n    }]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(function () {\n      return state.panning = false;\n    }, 500);\n    callback(state.options.pan.onPanComplete, [{\n      chart: chart\n    }]);\n  }\n}\nvar hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  var state = getState(chart);\n  var canvas = chart.canvas;\n  var panOptions = options.pan,\n    zoomOptions = options.zoom;\n  var mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', function () {\n      return startPinch(chart, state);\n    });\n    mc.on('pinch', function (e) {\n      return handlePinch(chart, state, e);\n    });\n    mc.on('pinchend', function (e) {\n      return endPinch(chart, state, e);\n    });\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', function (e) {\n      return startPan(chart, state, e);\n    });\n    mc.on('panmove', function (e) {\n      return handlePan(chart, state, e);\n    });\n    mc.on('panend', function () {\n      return endPan(chart, state);\n    });\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  var mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nvar version = \"2.0.1\";\nfunction draw(chart, caller, options) {\n  var dragOptions = options.zoom.drag;\n  var _getState4 = getState(chart),\n    dragStart = _getState4.dragStart,\n    dragEnd = _getState4.dragEnd;\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  var _computeDragRect = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd),\n    left = _computeDragRect.left,\n    top = _computeDragRect.top,\n    width = _computeDragRect.width,\n    height = _computeDragRect.height;\n  var ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version: version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function start(chart, _args, options) {\n    var state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode') || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = function (delta, panScales, transition) {\n      return pan(chart, delta, panScales, transition);\n    };\n    chart.zoom = function (args, transition) {\n      return zoom(chart, args, transition);\n    };\n    chart.zoomRect = function (p0, p1, transition) {\n      return zoomRect(chart, p0, p1, transition);\n    };\n    chart.zoomScale = function (id, range, transition) {\n      return zoomScale(chart, id, range, transition);\n    };\n    chart.resetZoom = function (transition) {\n      return resetZoom(chart, transition);\n    };\n    chart.getZoomLevel = function () {\n      return getZoomLevel(chart);\n    };\n    chart.getInitialScaleBounds = function () {\n      return getInitialScaleBounds(chart);\n    };\n    chart.isZoomedOrPanned = function () {\n      return isZoomedOrPanned(chart);\n    };\n  },\n  beforeEvent: function beforeEvent(chart) {\n    var state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n  beforeUpdate: function beforeUpdate(chart, args, options) {\n    var state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw: function beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw: function afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw: function beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw: function afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function stop(chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions: panFunctions,\n  zoomFunctions: zoomFunctions,\n  zoomRectFunctions: zoomRectFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };","map":{"version":3,"names":["Hammer","each","valueOrDefault","callback","sign","getRelativePosition","getModifierKey","opts","enabled","modifierKey","keyPressed","key","event","keyNotPressed","directionEnabled","mode","dir","chart","undefined","indexOf","directionsEnabled","x","y","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","_ref","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","options","point","_ref2","_ref2$mode","scaleMode","overScaleMode","scaleEnabled","overScaleEnabled","_i","_arr","axis","enabledScales","scaleItem","push","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","panDelta","set","removeState","delete","zoomDelta","zoom","center","range","max","min","newRange","centerPoint","isHorizontal","minPercent","Math","getValueForPixel","maxPercent","getLimit","scaleLimits","prop","fallback","limit","original","id","getRange","pixel0","pixel1","v0","v1","updateRange","_ref3","limits","arguments","scaleOpts","_scaleLimits$minRange","minRange","minLimit","Infinity","maxLimit","offset","parse","zoomNumericalScale","delta","zoomRectNumericalScale","from","to","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","canZoom","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","_ref4","_ref4$min","_ref4$max","panNonLinearScale","zoomFunctions","category","default","zoomRectFunctions","panFunctions","logarithmic","timeseries","shouldUpdateScaleLimits","_scale$options","previous","removeMissingScales","opt","storeOriginalScaleLimits","doZoom","amount","type","doZoomRect","getCenter","ca","chartArea","transition","_ref5","_ref5$x","_ref5$y","_ref5$focalPoint","focalPoint","_state$options","zoomOptions","xEnabled","yEnabled","update","onZoom","zoomRect","p0","p1","_state$options2","_zoomOptions$mode","zoomScale","scaleId","resetZoom","scaleOptions","onZoomComplete","getOriginalRange","getZoomLevel","origRange","level","panScale","storedDelta","pan","_ref6","_ref6$x","_ref6$y","_state$options3","panOptions","_ref7","onPan","getInitialScaleBounds","scaleBounds","_i2","_Object$keys","_ref8","isZoomedOrPanned","_i3","_Object$keys2","_scaleBounds$scaleId","originalMin","originalMax","removeHandler","_getState","handler","target","removeEventListener","addHandler","_getState2","oldHandler","addEventListener","mouseMove","dragStart","dragging","dragEnd","keyDown","zoomStart","onZoomStart","onZoomRejected","mouseDown","_state$options4","_state$options4$zoom","button","drag","canvas","window","document","computeDragRect","beginPointEvent","endPointEvent","_chart$chartArea","chartWidth","chartHeight","beginPoint","endPoint","zoomX","zoomY","mouseUp","_state$options$zoom","_state$options$zoom$d","threshold","rect","distanceX","distanceY","distance","sqrt","wheelPreconditions","wheel","cancelable","preventDefault","deltaY","_getState3","getBoundingClientRect","speed","clientX","clientY","addDebouncedHandler","name","addListeners","_options$zoom","wheelOptions","dragOptions","ownerDocument","removeListeners","createEnabler","recognizer","_state$options5","_state$options5$zoom","srcEvent","panning","pointerType","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","_state$options$pan","onPanStart","panEndTimeout","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","version","draw","caller","_getState4","drawTime","_computeDragRect","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","beforeUpdate","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","stop"],"sources":["/Users/tommymarkopoulos/Desktop/coding/Git_Repos/chess-app/chess-stats-app/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-zoom v2.0.1\n* undefined\n * (c) 2016-2023 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, callback, sign, getRelativePosition } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\n\n/**\n * @param {string|function} mode can be 'x', 'y' or 'xy'\n * @param {string} dir can be 'x' or 'y'\n * @param {import('chart.js').Chart} chart instance of the chart in question\n * @returns {boolean}\n */\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n\n  return false;\n}\n\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({chart});\n  }\n  if (typeof mode === 'string') {\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\n  }\n\n  return {x: false, y: false};\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n * @param {function} fn - Function to call. No arguments are passed.\n * @param {number} delay - Delay in ms. 0 = immediate invocation.\n * @returns {function}\n */\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\n\n/**\n * Checks which axis is under the mouse cursor.\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale}\n */\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\n\n/**\n * Evaluate the chart's mode, scaleMode, and overScaleMode properties to\n * determine which axes are eligible for scaling.\n * options.overScaleMode can be a function if user want zoom only one scale of many for example.\n * @param options - Zoom or pan options\n * @param {{x: number, y: number}} point - the mouse location\n * @param {import('chart.js').Chart} [chart] instance of the chart in question\n * @return {import('chart.js').Scale[]}\n */\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n\n  // Convert deprecated overScaleEnabled to new scaleEnabled.\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n\n  const centerPoint = scale.isHorizontal() ? center.x : center.y;\n  // `scale.getValueForPixel()` can return a value less than the `scale.min` or\n  // greater than `scale.max` when `centerPoint` is outside chartArea.\n  const minPercent = Math.max(0, Math.min(1,\n    (scale.getValueForPixel(centerPoint) - scale.min) / range || 0\n  ));\n\n  const maxPercent = 1 - minPercent;\n\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\n\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\n\nfunction getRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\n\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {id, axis, options: scaleOpts} = scale;\n\n  const scaleLimits = limits && (limits[id] || limits[axis]) || {};\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n\n  const range = zoom ? Math.max(max - min, minRange) : scale.max - scale.min;\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  scaleOpts.min = min;\n  scaleOpts.max = max;\n\n  state.updatedScaleLimits[scale.id] = {min, max};\n\n  // return true if the scale range is changed\n  return scale.parse(min) !== scale.min || scale.parse(max) !== scale.max;\n}\n\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, getRange(scale, from, to), limits, true);\n}\n\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\n\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\n\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = zoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\n\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\n\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  // The visible range. Ticks can be skipped, and thus not reliable.\n  const range = Math.max(max - min, 1);\n  // How many pixels of delta is required before making a step. stepSize, but limited to max 1/10 of the scale length.\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n\n  return updateRange(scale, {min, max}, limits) || applied;\n}\n\nconst OFFSETS = {\n  second: 500, // 500 ms\n  minute: 30 * 1000, // 30 s\n  hour: 30 * 60 * 1000, // 30 m\n  day: 12 * 60 * 60 * 1000, // 12 h\n  week: 3.5 * 24 * 60 * 60 * 1000, // 3.5 d\n  month: 15 * 24 * 60 * 60 * 1000, // 15 d\n  quarter: 60 * 24 * 60 * 60 * 1000, // 60 d\n  year: 182 * 24 * 60 * 60 * 1000 // 182 d\n};\n\nfunction panNumericalScale(scale, delta, limits, canZoom = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  const {min: minLimit = -Infinity, max: maxLimit = Infinity} = canZoom && limits && limits[scale.axis] || {};\n  if (isNaN(newMin) || isNaN(newMax) || newMin < minLimit || newMax > maxLimit) {\n    // At limit: No change but return true to indicate no need to store the delta.\n    // NaN can happen for 0-dimension scales (either because they were configured\n    // with min === max or because the chart has 0 plottable area).\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, canZoom);\n}\n\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\n\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n};\n\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale,\n};\n\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\n\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\n\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n\n  each(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\n\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\n\nfunction doZoomRect(scale, amount, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, amount, from, to, limits]);\n}\n\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\n\n/**\n * @param chart The chart instance\n * @param {number | {x?: number, y?: number, focalPoint?: {x: number, y: number}}} amount The zoom percentage or percentages and focal point\n * @param {string} [transition] Which transition mode to use. Defaults to 'none'\n */\nfunction zoom(chart, amount, transition = 'none') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomRect(chart, p0, p1, transition = 'none') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(zoomOptions.onZoom, [{chart}]);\n}\n\nfunction zoomScale(chart, scaleId, range, transition = 'none') {\n  storeOriginalScaleLimits(chart, getState(chart));\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n}\n\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\n}\n\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\n\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\n\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  // Add possible cumulative delta from previous pan attempts where scale did not change\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    // The scale changed, reset cumulative delta\n    panDelta[scale.id] = 0;\n  } else {\n    // The scale did not change, store cumulative delta\n    panDelta[scale.id] = delta;\n  }\n}\n\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {onPan} = panOptions || {};\n\n  storeOriginalScaleLimits(chart, state);\n\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n\n  chart.update(transition);\n\n  callback(onPan, [{chart}]);\n}\n\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n\n  return scaleBounds;\n}\n\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\n\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    // already attached\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  target.addEventListener(type, handlers[type]);\n}\n\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\n\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\n\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const point = getRelativePosition(event, chart);\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\n\nfunction mouseDown(chart, event) {\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n\n  addHandler(chart, chart.canvas, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\n\nfunction computeDragRect(chart, mode, beginPointEvent, endPointEvent) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  let {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n\n  const beginPoint = getRelativePosition(beginPointEvent, chart);\n  const endPoint = getRelativePosition(endPointEvent, chart);\n\n  if (xEnabled) {\n    left = Math.min(beginPoint.x, endPoint.x);\n    right = Math.max(beginPoint.x, endPoint.x);\n  }\n\n  if (yEnabled) {\n    top = Math.min(beginPoint.y, endPoint.y);\n    bottom = Math.max(beginPoint.y, endPoint.y);\n  }\n  const width = right - left;\n  const height = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\n\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, state.dragStart, event);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n  // Remove drag start and end before chart update to stop drawing selected area\n  state.dragStart = state.dragEnd = null;\n\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom');\n\n  setTimeout(() => (state.dragging = false), 500);\n  callback(onZoomComplete, [{chart}]);\n}\n\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  // Before preventDefault, check if the modifier key required and pressed\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n\n  // Prevent the event from triggering the default behavior (e.g. content scrolling).\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  // Firefox always fires the wheel event twice:\n  // First without the delta and right after that once with the delta properties.\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\n\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n\n  const rect = event.target.getBoundingClientRect();\n  const speed = 1 + (event.deltaY >= 0 ? -zoomOptions.wheel.speed : zoomOptions.wheel.speed);\n  const amount = {\n    x: speed,\n    y: speed,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n\n  zoom(chart, amount);\n\n  if (onZoomComplete) {\n    onZoomComplete();\n  }\n}\n\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\n\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n\n  // Install listeners. Do this dynamically based on options so that we can turn zoom on and off\n  // We also want to make sure listeners aren't always on. E.g. if you're scrolling down a page\n  // and the mouse goes over a chart you don't want it intercepted unless the plugin is enabled\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\n\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) { // Sometimes Hammer queries this with a null event.\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\n\nfunction pinchAxes(p0, p1) {\n  // fingers position difference\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n\n  // diagonal fingers will change both (xy) axes\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\n\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    // Hammer reports the total scaling. We need the incremental amount\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n\n    zoom(chart, amount);\n\n    // Keep track of overall scale\n    state.scale = e.scale;\n  }\n}\n\nfunction startPinch(chart, state) {\n  if (state.options.zoom.pinch.enabled) {\n    state.scale = 1;\n  }\n}\n\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null; // reset\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\n\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\n\nfunction startPan(chart, state, event) {\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {x: 0, y: 0};\n  clearTimeout(state.panEndTimeout);\n  handlePan(chart, state, event);\n}\n\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panEndTimeout = setTimeout(() => (state.panning = false), 500);\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\n\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', () => startPinch(chart, state));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n\n  hammers.set(chart, mc);\n}\n\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\n\nvar version = \"2.0.1\";\n\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {dragStart, dragEnd} = getState(chart);\n\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, dragStart, dragEnd);\n  const ctx = chart.ctx;\n\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\n\nvar plugin = {\n  id: 'zoom',\n\n  version,\n\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n  },\n\n  beforeEvent(chart) {\n    const state = getState(chart);\n    if (state.panning || state.dragging) {\n      // cancel any event handling while panning or dragging\n      return false;\n    }\n  },\n\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    state.options = options;\n    addListeners(chart, options);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n\n  stop: function(chart) {\n    removeListeners(chart);\n\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n};\n\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}